## Назначение

Task Execution Workflow гарантирует, что все задачи разработки выполняются систематически, с тщательной валидацией и документацией для поддержания качества кода, консистентности и соответствия требованиям MVP проекта. Этот workflow обязателен для CursorAI агента при выполнении каждой задачи.

---

## Task Execution Workflow

CursorAI агент должен следовать шагам ниже для каждой задачи разработки, чтобы обеспечить соответствие техническим, функциональным и дизайн требованиям проекта.

### Шаг 1: Анализ задачи

- **Цель**: Понять требования задачи и согласовать с архитектурой проекта.
- **Действия**:
  - Изучить описание задачи и сверить с релевантными разделами:
    - [`docs/prds/MVP_SCOPE.md`](docs/prds/MVP_SCOPE.md) - что входит и не входит в MVP.
    - [`docs/prds/ARCHITECTURE.md`](docs/prds/ARCHITECTURE.md) - техническая архитектура проекта.
    - [`docs/prds/IMPLEMENTATION_PLAN.md`](docs/prds/IMPLEMENTATION_PLAN.md) - план реализации MVP.
    - [`docs/tasks/mvp_tasks.md`](docs/tasks/mvp_tasks.md) - список задач проекта (если существует).
    - [`docs/guidelines/react/`](docs/guidelines/react/) - guidelines для React компонентов, hooks, utilities.
    - [`prisma/schema.prisma`](prisma/schema.prisma) - схема базы данных.
  - Определить тип задачи:
    - **Teacher компонент** → `src/components/teacher/`
    - **Admin компонент** → `src/components/admin/`
    - **Общий компонент** → `src/components/shared/`
    - **Server Action** → `src/actions/`
    - **Страница** → `src/app/` (App Router)
    - **Утилита** → `src/lib/`
  - Определить, требуется ли Server Component (по умолчанию) или Client Component (только для интерактивности).
  - Проверить, требует ли задача работы с БД (Prisma), аутентификации (Auth.js), или Supabase Storage.
  - **Автоматическое использование Context7 MCP сервера**:
    - **Обязательное правило**: Если задача связана с использованием библиотек или фреймворков (Next.js, React, Prisma, TypeScript, Zod, Shadcn UI, react-hook-form, Auth.js, Tailwind CSS, BlockNote и т.д.), CursorAI агент **автоматически** должен использовать Context7 для получения актуальной документации.
    - **Критерии автоматического использования Context7**:
      - Задача связана с Next.js (Server Actions, App Router, routing, middleware)
      - Задача связана с React (компоненты, хуки, паттерны)
      - Задача связана с Prisma (запросы, миграции, схемы)
      - Задача связана с валидацией (Zod, react-hook-form)
      - Задача связана с UI библиотеками (Shadcn UI, Tailwind CSS)
      - Задача связана с аутентификацией (Auth.js, next-auth)
      - Задача связана с BlockNote (rich text editor для уроков)
      - Задача требует актуальной документации или примеров кода
    - **Действие CursorAI**: При определении, что задача соответствует критериям выше, **автоматически** использовать Context7 MCP сервер для получения актуальной документации, **не требуя** явного указания `use context7` от пользователя.
    - Это обеспечит получение актуальной, версионно-специфичной документации и примеров кода без необходимости явного указания пользователем.
  - Документ должен включать:
    - Пошаговые инструкции по реализации на русском языке.
    - Примеры кода с объяснениями, следующие структуре проекта.
    - Ссылки на архитектуру и guidelines.
    - Детали соответствия архитектуре (размещение файлов, импорты).
    - Альтернативные подходы с плюсами и минусами.
    - Обоснование выбранного подхода.
    - Зависимости от других задач или сервисов.

### Шаг 2: Реализация кода

- **Цель**: Реализовать задачу, следуя архитектуре проекта и лучшим практикам.
- **Действия**:
  - Разместить код в соответствующей папке согласно структуре проекта:
    - **`components/ui/`**: Компоненты Shadcn UI (отдельная папка, устанавливаются через `npx shadcn@latest add`).
    - **`components/teacher/`**: Компоненты для преподавателей (LessonForm, HomeworkCheckTable, PupilCard, LeaderboardTable, ScheduleCalendar).
    - **`components/admin/`**: Компоненты для админ-панели (AdminSidebar, AdminBreadcrumbs, TeachersTable, PupilsTable, FamiliesTable, GradeSettingsForm).
    - **`components/shared/`**: Общие компоненты (Header, Footer, LoadingSpinner, ErrorMessage).
    - **`actions/`**: Server Actions для CRUD операций (lessons.ts, homework.ts, pupils.ts, teachers.ts, grades.ts, academic-years.ts, golden-verses.ts, achievements.ts, families.ts, schedule.ts, admin.ts).
    - **`app/`**: Next.js App Router страницы (orchestration only).
    - **`lib/`**: Утилиты и helpers (db, auth, utils).
  - Соблюдать строгую типизацию TypeScript, запрещая использование `any` типов. Определять конкретные типы в соответствующих файлах.
  - Использовать **Zod schemas как единый источник истины** для валидации. Выводить TypeScript типы используя `z.infer<typeof Schema>`.
  - Реализовывать **Server Components по умолчанию**. Добавлять `'use client'` только когда требуется интерактивность (useState, useEffect, event handlers).
  - Для Server Actions, следовать паттернам:
    - Размещать в `actions/{entity}.ts` (например, `actions/lessons.ts`, `actions/homework.ts`, `actions/pupils.ts`).
    - Включать директиву `'use server'`.
    - Проверка аутентификации через Auth.js (только для админских действий и действий преподавателей).
    - Валидация входных данных используя Zod schemas.
    - Выполнение бизнес-логики (Prisma операции).
    - Возврат discriminated unions: `{ success: true, data?: T } | { success: false, error: string }`.
  - Для UI компонентов, следовать [`docs/guidelines/react/ai_component_guidelines.md`](docs/guidelines/react/ai_component_guidelines.md):
    - Использовать компоненты Shadcn UI из `components/ui/`.
    - Применять Atomic Design иерархию: Atoms → Molecules → Organisms.
    - Использовать Tailwind CSS 4 с семантическими классами.
    - Обеспечивать WCAG 2.1 AA доступность (навигация с клавиатуры, ARIA labels, контраст 4.5:1).
  - Для React hooks, следовать [`docs/guidelines/react/ai_react_hooks_guidelines.md`](docs/guidelines/react/ai_react_hooks_guidelines.md):
    - Размещать в `hooks/` директории.
    - Использовать Zustand для клиентского состояния (минимально, только когда нужно).
    - Использовать Server Components для публичных страниц (hooks не нужны).
  - Для utility функций, следовать [`docs/guidelines/react/ai_react_utilities_guidelines.md`](docs/guidelines/react/ai_react_utilities_guidelines.md):
    - Размещать в `lib/` для глобальных утилит.
    - Обеспечивать чистые функции (без side effects).
    - Использовать named exports для tree-shaking.
  - Добавлять комментарии на русском языке с JSDoc для сложной логики.
  - **Автоматическое использование Context7 при работе с библиотеками**:
    - **Обязательное правило**: При реализации кода, использующего библиотеки (Next.js, React, Prisma, Zod, Shadcn UI, BlockNote и т.д.), CursorAI агент **автоматически** должен использовать Context7 MCP сервер для получения актуальной документации.
    - **Автоматическое определение необходимости**:
      - Если код использует Next.js API → автоматически использовать Context7
      - Если код использует React паттерны → автоматически использовать Context7
      - Если код использует Prisma → автоматически использовать Context7
      - Если код использует Zod для валидации → автоматически использовать Context7
      - Если код использует Shadcn UI компоненты → автоматически использовать Context7
      - Если код использует react-hook-form → автоматически использовать Context7
      - Если код использует Auth.js → автоматически использовать Context7
      - Если код использует BlockNote → автоматически использовать Context7
    - **Действие CursorAI**: При реализации кода, соответствующего критериям выше, **автоматически** обращаться к Context7 MCP серверу для получения актуальной документации, **без явного указания** `use context7` в запросе пользователя.
    - Это обеспечит использование актуальных API, правильных паттернов и best practices для конкретных версий библиотек.
    - **Важно**: Context7 должен использоваться автоматически на основе типа задачи, а не только при явном указании пользователя.
  - **Важно для MVP**: Фокус на работоспособность, не на идеальный код. Можно упростить для быстрого запуска.

### Шаг 3: Валидация TypeScript

- **Цель**: Обеспечить типобезопасность и устранить ошибки TypeScript.
- **Действия**:
  - Запустить `npx tsc --noEmit` для проверки ошибок TypeScript. Использовать эту команду на этом шаге.
  - Если обнаружены ошибки (например, `Unexpected any`, отсутствующие типы):
    - Исправить ошибки, определив конкретные типы в соответствующих файлах.
    - Убедиться, что все типы следуют паттернам из guidelines.
    - Использовать `z.infer<typeof Schema>` для типов, выведенных из Zod schemas.
    - Перезапустить `npx tsc --noEmit` до тех пор, пока ошибки не исчезнут.
  - Задокументировать любые исправления типов в описании задачи.

### Шаг 4: Линтинг

- **Цель**: Обеспечить соответствие кода стандартам линтинга.
- **Действия**:
  - Запустить `npm run lint` для обнаружения проблем линтинга, включая предупреждения типа `Unexpected any. Specify a different type`.
  - Если обнаружены проблемы:
    - Исправить каждую проблему (например, заменить `any` на конкретные типы, исправить форматирование).
    - Убедиться, что импорты корректны.
    - Перезапустить `npm run lint` до тех пор, пока проблемы не исчезнут.
  - Убедиться, что весь код соответствует ESLint и Prettier стандартам.

### Шаг 4.5: Проверка UI в браузере (⭐ **ОБЯЗАТЕЛЬНО для UI компонентов**)

- **Цель**: Убедиться в корректном отображении компонентов пользовательского интерфейса и отсутствии ошибок в браузере.
- **Условие**: Этот шаг выполняется **ОБЯЗАТЕЛЬНО**, если изменения касались компонентов пользовательского интерфейса (UI компоненты, страницы, layouts).
- **Важно**: Проверка консоли браузера является **критически важной** частью этого шага и **НЕ МОЖЕТ** быть пропущена. Ошибки в консоли браузера могут не проявляться при сборке, но будут видны пользователям в production.
- **Действия**:

#### 4.5.1. Автоматическая проверка (выполняется CursorAI)

- **Запуск development сервера**:
  - Запустить `npm run dev` для запуска development сервера.
  - Дождаться успешного запуска сервера.

- **Открытие страниц в браузере**:
  - Открыть соответствующие страницы в браузере, встроенном в CursorAI, используя функцию навигации браузера.
  - Убедиться, что страница загрузилась без критических ошибок.

- **Проверка консоли браузера на ошибки** (⭐ **ОБЯЗАТЕЛЬНО**):
  > ⚠️ **КРИТИЧЕСКИ ВАЖНО**: Проверка консоли браузера является **обязательным** шагом при создании или изменении любого UI компонента. Этот шаг **НЕ МОЖЕТ** быть пропущен.
  
  - **Метод 1: Использование MCP инструментов (предпочтительно)**:
    - Использовать `mcp_console-ninja_runtime-errors` для получения всех ошибок runtime из браузера.
    - Использовать `mcp_console-ninja_runtime-logs` для получения всех логов из браузера.
    - Использовать `mcp_console-ninja_runtime-logs-and-errors` для получения всех ошибок и логов одновременно.
    - Если компонент уже открыт в браузере, использовать `mcp_console-ninja_runtime-logs-by-location` с указанием файла и строки для проверки конкретного компонента.
    - **Проверка должна включать**:
      - JavaScript ошибки (SyntaxError, TypeError, ReferenceError и т.д.)
      - React ошибки (hydration errors, render errors, hook errors)
      - Предупреждения React (deprecated API, missing keys, etc.)
      - Ошибки сериализации (например, "Only plain objects can be passed to Client Components")
      - Ошибки импорта модулей
      - Ошибки выполнения Server Actions
      - Ошибки работы с Prisma (если применимо)
      - Ошибки валидации Zod (если применимо)
    - **Если обнаружены ошибки**:
      1. Зафиксировать все найденные ошибки с их типами и сообщениями.
      2. Определить источник ошибки (какой компонент, какая строка кода).
      3. Исправить ошибки в коде согласно их типу:
         - **Ошибки сериализации**: Преобразовать несериализуемые типы (Decimal, Date) в строки перед передачей в Client Components.
         - **React ошибки**: Проверить правильность использования hooks, проверить зависимости useEffect, проверить ключи в списках.
         - **TypeScript ошибки**: Убедиться, что все типы определены корректно.
         - **Ошибки импорта**: Проверить пути импорта, убедиться, что файлы существуют.
         - **Ошибки валидации**: Проверить Zod schemas и соответствие данных схемам.
      4. Сохранить изменения в файлах.
      5. Дождаться автоматической перезагрузки страницы (Hot Module Replacement).
      6. Повторно проверить консоль браузера используя MCP инструменты.
      7. Повторять шаги 3-6 до тех пор, пока все ошибки не будут устранены.
    - **Если ошибок не обнаружено**:
      - Задокументировать успешную проверку: "✅ Консоль браузера проверена через MCP инструменты - ошибок не обнаружено."
      - Перейти к следующему шагу проверки.
  
  - **Метод 2: Ручная проверка через Developer Tools (если MCP недоступен)**:
    - Открыть страницу в браузере (если еще не открыта).
    - Открыть Developer Tools одним из способов:
      - Нажать `F12` на клавиатуре.
      - Нажать `Ctrl+Shift+I` (Windows/Linux) или `Cmd+Option+I` (Mac).
      - Правый клик на странице → "Inspect" или "Проверить элемент".
    - Перейти на вкладку **Console**.
    - **Проверить фильтры консоли**:
      - Убедиться, что включены фильтры для отображения всех типов сообщений:
        - ✅ Errors (ошибки) - **обязательно**
        - ✅ Warnings (предупреждения) - **обязательно**
        - ✅ Info (информация) - рекомендуется
        - ⚠️ Verbose (подробные) - опционально
    - **Проверить наличие ошибок**:
      - Ошибки отображаются красным цветом с иконкой ❌ или ⚠️.
      - Обратить внимание на:
        - **Красные сообщения** - критические ошибки, которые блокируют работу приложения.
        - **Желтые предупреждения** - предупреждения, которые могут указывать на потенциальные проблемы.
        - **Стек вызовов (stack trace)** - кликнуть на ошибку, чтобы увидеть, где именно она возникла.
    - **Проверить вкладку Network** (если применимо):
      - Перейти на вкладку **Network** в Developer Tools.
      - Обновить страницу (F5 или Ctrl+R).
      - Проверить наличие failed запросов (красным цветом):
        - Failed API запросы к Server Actions
        - Failed запросы к базе данных
        - Failed загрузки ресурсов (изображения, стили, скрипты)
      - Если обнаружены failed запросы:
        - Кликнуть на failed запрос для просмотра деталей.
        - Проверить статус код (404, 500, и т.д.).
        - Проверить Response для понимания причины ошибки.
        - Исправить проблему в коде.
    - **Проверить вкладку React DevTools** (если установлена):
      - Установить расширение React Developer Tools для браузера (если еще не установлено).
      - Открыть вкладку **Components** в React DevTools.
      - Проверить компоненты на наличие предупреждений:
        - Missing keys в списках
        - Deprecated API usage
        - Performance warnings
    - **Если обнаружены ошибки**:
      1. Скопировать полный текст ошибки (включая stack trace).
      2. Определить источник ошибки по stack trace:
         - Найти файл и строку, где возникла ошибка.
         - Определить, какой компонент вызвал ошибку.
      3. Исправить ошибку в коде согласно типу ошибки (см. Метод 1, шаг 3).
      4. Сохранить изменения.
      5. Обновить страницу в браузере (F5 или Ctrl+R).
      6. Повторно проверить консоль.
      7. Повторять шаги 3-6 до тех пор, пока все ошибки не будут устранены.
    - **Если ошибок не обнаружено**:
      - Задокументировать успешную проверку: "✅ Консоль браузера проверена вручную через Developer Tools - ошибок не обнаружено."
      - Перейти к следующему шагу проверки.
  
  - **Типичные ошибки и их решения**:
    - **"Only plain objects can be passed to Client Components"**:
      - **Причина**: Попытка передать несериализуемый объект (Decimal, Date, функция) от Server Component к Client Component.
      - **Решение**: Преобразовать Decimal в строку (`.toString()`), Date в ISO строку (`.toISOString()`) перед передачей.
      - **Пример**: Создать функцию `serializeLesson()` для преобразования Lesson с Decimal в сериализуемый формат.
    
    - **"Hydration failed"**:
      - **Причина**: Несоответствие HTML между сервером и клиентом (например, использование `Date.now()` или `Math.random()` в render).
      - **Решение**: Убедиться, что Server и Client Components рендерят одинаковый HTML, использовать `useEffect` для клиентских данных.
    
    - **"Cannot read property 'X' of undefined"**:
      - **Причина**: Попытка доступа к свойству несуществующего объекта.
      - **Решение**: Добавить проверки на существование объекта (`?.` optional chaining, проверки `if`).
    
    - **"Invalid hook call"**:
      - **Причина**: Использование React hooks вне компонента или в неправильном порядке.
      - **Решение**: Убедиться, что hooks используются только в функциональных компонентах, соблюдать правила hooks.
    
    - **"Module not found"**:
      - **Причина**: Неправильный путь импорта или отсутствующий файл.
      - **Решение**: Проверить пути импорта, убедиться, что файлы существуют, проверить регистр букв в путях.
    
    - **"Zod validation error"**:
      - **Причина**: Данные не соответствуют Zod schema.
      - **Решение**: Проверить структуру данных, убедиться, что все обязательные поля присутствуют, проверить типы данных.
  
  - **Документирование результатов**:
    - Задокументировать результаты проверки консоли:
      - Если ошибок не было: "✅ Консоль браузера проверена - ошибок не обнаружено."
      - Если были ошибки: "⚠️ Обнаружены ошибки в консоли: [список ошибок]. Исправлено: [описание исправлений]."
    - Указать метод проверки (MCP инструменты или Developer Tools).
    - Указать время проверки и версию компонента.
  
  - **Критерии успешной проверки**:
    - ✅ Ноль ошибок (Errors) в консоли браузера.
    - ✅ Ноль критических предупреждений (Warnings), которые могут влиять на функциональность.
    - ✅ Нет failed запросов в Network tab (если применимо).
    - ✅ Страница загружается без ошибок.
    - ✅ Все интерактивные элементы работают корректно.
  
  - **Важно**: 
    - Проверка консоли браузера **ОБЯЗАТЕЛЬНА** для всех UI компонентов.
    - Нельзя пропускать этот шаг, даже если TypeScript и линтинг прошли успешно.
    - Ошибки в консоли браузера могут не проявляться при сборке, но будут видны пользователям в production.
    - Все ошибки должны быть исправлены **ДО** перехода к следующему шагу workflow.

- **Проверка базовой функциональности**:
  - Проверить, что страница загружается без ошибок.
  - Проверить, что базовые интерактивные элементы реагируют на клики (кнопки, ссылки).
  - Проверить, что навигация работает (ссылки ведут на правильные URL).
  - Если обнаружены проблемы с базовой функциональностью:
    - Исправить логику компонента.
    - Перезагрузить страницу и проверить снова.
    - Повторять до тех пор, пока базовая функциональность не работает корректно.

#### 4.5.2. Визуальная проверка (требует человеческого вмешательства)

> ⚠️ **Важно**: Следующие проверки требуют визуальной оценки человеком и не могут быть полностью автоматизированы. CursorAI должен **указать разработчику** на необходимость выполнения этих проверок.

- **Визуальное соответствие дизайну**:
  - Проверить визуальное соответствие компонентов дизайну и требованиям.
  - Убедиться, что цвета, шрифты, отступы соответствуют дизайн-системе.
  - **Действие CursorAI**: Указать разработчику на необходимость визуальной проверки.

- **UX интерактивных элементов**:
  - Проверить корректную работу интерактивных элементов (кнопки, формы, модальные окна).
  - Убедиться, что анимации и переходы работают плавно.
  - Проверить feedback при взаимодействии (hover, focus, active состояния).
  - **Действие CursorAI**: Указать разработчику на необходимость проверки UX.

- **Адаптивность на разных размерах экрана**:
  - Проверить адаптивность на разных размерах экрана (mobile, tablet, desktop).
  - Убедиться, что компоненты корректно отображаются на всех разрешениях.
  - Проверить, что нет горизонтальной прокрутки на мобильных устройствах.
  - **Действие CursorAI**: Указать разработчику на необходимость проверки адаптивности.

- **Документирование результатов**:
  - Задокументировать результаты автоматической проверки в описании задачи.
  - Указать, какие визуальные проверки требуют внимания разработчика.

- **Примечание**: 
  - Этот шаг можно пропустить **ТОЛЬКО** если изменения касались исключительно Server Actions, утилит, или других не-UI компонентов, которые **НЕ ВЛИЯЮТ** на отображение в браузере.
  - Если изменения в Server Actions или утилитах могут влиять на UI (например, изменение структуры данных, передаваемых в компоненты), проверка консоли браузера **ОБЯЗАТЕЛЬНА**.
  - В случае сомнений - **всегда выполнять проверку консоли браузера**.

### Шаг 5: Валидация сборки

- **Цель**: Убедиться, что проект успешно собирается без ошибок.
- **Действия**:
  - Запустить `npm run build` для проверки ошибок сборки.
  - Если обнаружены ошибки (например, отсутствующие импорты, некорректные конфигурации):
    - Исправить ошибки и задокументировать исправления.
    - Убедиться, что все импорты корректны.
    - Проверить конфигурацию Prisma и Supabase.
    - Перезапустить `npm run build` до тех пор, пока сборка не пройдет успешно.
  - Задокументировать любые исправления сборки в описании задачи.

### Шаг 6: Симуляция Code Review

- **Цель**: Обеспечить качество кода и соответствие архитектуре через self-review.
- **Действия**:
  - Симулировать code review, проверяя:
    - **Соответствие архитектуре**: Правильное размещение файлов, корректные импорты.
    - **Требования TypeScript**: Строгая типизация, Zod schemas как единый источник истины, `z.infer<typeof Schema>`.
    - **Server Actions**: Директива `'use server'`, Auth.js проверка (для админских действий и действий преподавателей), Zod валидация, discriminated unions.
    - **Архитектура компонентов**: Server Components по умолчанию, Client Components только для интерактивности, Atomic Design иерархия.
    - **Интеграция с БД**: Правильное использование Prisma, корректные запросы, обработка ошибок.
    - **Supabase Storage**: Правильное использование для файлов (если применимо).
    - **Доступность**: Соответствие WCAG 2.1 AA, навигация с клавиатуры, ARIA labels, контраст цветов 4.5:1.
    - **Производительность**: SSG/ISR для публичных страниц, оптимизация изображений (next/image), lazy loading.
    - **Безопасность**: Валидация входных данных, обработка ошибок. **Примечание**: Защита админ-панели и приватных страниц будет добавлена на завершающей стадии проекта.
    - **Качество кода**: Понятные JSDoc комментарии, консистентное именование, правильная обработка ошибок.
    - **MVP подход**: Код работает, даже если не идеален. Можно упростить для быстрого запуска.
  - Если найдены проблемы, пересмотреть код и повторить Шаги 3–5 при необходимости.
  - Задокументировать любые пересмотры в описании задачи.

### Шаг 7: Обновление документации

- **Цель**: Обеспечить комплексную документацию задачи.
- **Действия**:
  - Обновить или завершить описание задачи с:
    - Детальными шагами реализации, следующими структуре проекта.
    - Примерами кода с объяснениями, демонстрирующими правильное размещение файлов.
    - Результатами валидации (TypeScript, линтинг, сборка).
    - Любыми отклонениями от запланированного подхода и их обоснованием.
    - Зависимостями от других задач или сервисов.
    - Ссылками на релевантные guidelines.
  - Если задача влияет на структуру проекта, обновить соответствующие документы.
  - Если задача влияет на схему БД, обновить `prisma/schema.prisma` и создать миграцию.
  - **Обновить статус задачи в [`docs/tasks/mvp_tasks.md`](docs/tasks/mvp_tasks.md)** (если файл существует):
    - Найти соответствующую задачу в файле `docs/tasks/mvp_tasks.md`.
    - Изменить статус задачи с `- [ ]` на `- [x]` после успешного выполнения всех шагов workflow.
    - Убедиться, что задача соответствует выполненной работе.
    - Если задача была разбита на подзадачи, обновить статус всех выполненных подзадач.
  - Если задача влияет на план разработки, обновить [`docs/prds/IMPLEMENTATION_PLAN.md`](docs/prds/IMPLEMENTATION_PLAN.md) с дополнительной информацией.
  - Убедиться, что вся документация и комментарии кода на русском языке.

---

## ⚠️ КРИТИЧЕСКИ ВАЖНО: Валидация после блока задач

**Обязательное правило**: После завершения выполнения **каждого блока задач** из [`docs/prds/IMPLEMENTATION_PLAN.md`](docs/prds/IMPLEMENTATION_PLAN.md) (например, "Установка зависимостей", "Shadcn UI", "База данных", "Структура проекта" и т.д.), CursorAI агент **ОБЯЗАН** выполнить полную цепочку валидации:

1. **Валидация TypeScript** (`npx tsc --noEmit`)
2. **Линтинг** (`npm run lint`)
3. **Проверка консоли браузера** (⭐ **ОБЯЗАТЕЛЬНО для UI компонентов**):
   - Если блок задач включал создание или изменение UI компонентов, **ОБЯЗАТЕЛЬНО** проверить консоль браузера на наличие ошибок.
   - Использовать MCP инструменты (`mcp_console-ninja_runtime-errors`, `mcp_console-ninja_runtime-logs-and-errors`) или Developer Tools.
   - Убедиться, что нет ошибок JavaScript, React ошибок, ошибок сериализации, ошибок импорта.
   - Все ошибки должны быть исправлены **ДО** перехода к следующему шагу.
4. **Валидация сборки** (`npm run build`) ⭐ **КРИТИЧЕСКИ ВАЖНО**

**Это правило применяется:**
- После завершения каждого логического блока задач (раздел с заголовком `#####`)
- После выполнения группы связанных задач (например, все задачи установки зависимостей)
- Перед обновлением статусов задач в `docs/tasks/mvp_tasks.md` (если файл существует)
- Перед переходом к следующему блоку задач

**Если валидация сборки не прошла:**
- НЕ обновлять статусы задач как выполненные
- Исправить все ошибки сборки
- Повторно запустить полную цепочку валидации
- Только после успешного прохождения всех проверок обновлять статусы

**Пример применения:**
```
Блок задач: "Создание UI компонентов" (строки 100-150)
✅ Выполнено: Созданы все UI компоненты
✅ Валидация TypeScript: пройдена
✅ Линтинг: пройден
✅ Проверка консоли браузера: пройдена ← ОБЯЗАТЕЛЬНО для UI компонентов!
✅ Валидация сборки: пройдена ← ОБЯЗАТЕЛЬНО!
✅ Обновлены статусы в mvp_tasks.md (если существует)
→ Переход к следующему блоку задач
```

**Важно**: Валидация сборки (`npm run build`) является **обязательным** шагом и не может быть пропущена, даже если предыдущие шаги валидации прошли успешно. Это гарантирует, что проект собирается без ошибок и готов к деплою.

---

## Метрики успеха

- **Качество кода**:
  - Ноль ошибок TypeScript (`npx tsc --noEmit`).
  - Ноль проблем линтинга (`npm run lint`).
  - Успешные сборки (`npm run build`).
  - **Ноль ошибок в консоли браузера** (⭐ **ОБЯЗАТЕЛЬНО для UI компонентов**).
  - Соответствие архитектуре проекта (правильное размещение файлов, корректные импорты).
- **Соответствие архитектуре**:
  - Следование структуре проекта (components/ui, components/teacher, components/admin, actions).
  - Интеграция с Prisma и Supabase.
  - Server Components по умолчанию, Client Components только когда нужно.
  - Zod schemas как единый источник истины для валидации.
  - Shadcn UI компоненты в отдельной папке `components/ui/`.
- **Документация**: Описание задачи завершено, на русском языке, и включает все требуемые разделы со ссылками на guidelines.

---

## Обработка ошибок и восстановление

- **Обработка ошибок**:
  - Реализовать комплексную обработку ошибок в Server Actions с понятными сообщениями для пользователя.
  - Использовать discriminated unions для ответов об ошибках: `{ success: false, error: string }`.
  - Логировать ошибки в консоль для отладки (в продакшене можно добавить Sentry).
  - Валидировать все пользовательские входные данные используя Zod schemas.
  - Возвращать осмысленные ответы об ошибках клиенту.
- **Процедуры восстановления**:
  - Если ошибки TypeScript, линтинга или сборки сохраняются после нескольких попыток:
    - Откатиться к последнему рабочему состоянию используя git.
    - Задокументировать проблему и попытки решения в описании задачи.
    - Проверить архитектуру проекта для альтернативных подходов реализации.
    - Обратиться к guidelines для конкретных паттернов (компоненты, hooks, типы и т.д.).

---

## Пример выполнения задачи

**Задача**: Реализовать форму создания урока для преподавателя.

**Workflow**:
1. **Анализ задачи**:
   - Изучить [`docs/prds/MVP_SCOPE.md`](docs/prds/MVP_SCOPE.md) для понимания требований к форме урока.
   - Проверить [`docs/prds/ARCHITECTURE.md`](docs/prds/ARCHITECTURE.md) для структуры проекта.
   - Определить это как задачу `components/teacher/LessonForm.tsx` (Client Component) и `actions/lessons.ts` (Server Action).
   - Ссылаться на [`docs/guidelines/react/ai_component_guidelines.md`](docs/guidelines/react/ai_component_guidelines.md) для паттернов компонентов.
   - **Автоматически использовать Context7**: Задача связана с Next.js Server Actions, React, Prisma, Zod, react-hook-form, BlockNote - CursorAI агент **автоматически** определяет необходимость использования Context7 и обращается к нему для получения актуальной документации без явного указания пользователя.

2. **Реализация кода**:
   - **Автоматическое использование Context7**: CursorAI агент **автоматически** использует Context7 MCP сервер при реализации:
     - Server Action (Next.js Server Actions, Prisma, Zod валидация)
     - Компонента формы (react-hook-form, Shadcn UI Dialog, BlockNote editor)
   - Агент самостоятельно обращается к Context7 для получения актуальной документации по:
     - Next.js Server Actions паттернам
     - Prisma запросам и операциям
     - Zod валидации
     - react-hook-form использованию
     - Shadcn UI компонентам
     - BlockNote интеграции
   - Создать `src/components/teacher/LessonForm.tsx` используя Dialog из `components/ui/`, BlockNote для описания урока и Tailwind CSS 4.
   - Реализовать `src/actions/lessons.ts` с:
     - Директивой `'use server'`
     - Zod валидацией используя `LessonSchema` (актуальные паттерны из Context7)
     - Prisma операцией для создания урока в БД (актуальные паттерны из Context7)
     - Проверкой прав доступа (Teacher - только своя группа, Admin - все группы)
     - Discriminated union типом возврата
   - Определить типы используя `z.infer<typeof LessonSchema>`.
   - Использовать react-hook-form для управления формой (актуальные паттерны из Context7).
   - Интегрировать BlockNote для редактирования описания урока.

3. **Валидация TypeScript**:
   - Запустить `npx tsc --noEmit` и исправить любые ошибки типов.
   - Убедиться, что все типы следуют паттернам из guidelines.
   - Перезапустить до тех пор, пока ошибки не исчезнут.

4. **Линтинг**:
   - Запустить `npm run lint` и решить любые проблемы.
   - Убедиться, что импорты корректны.
   - Перезапустить до тех пор, пока проблемы не исчезнут.

4.5. **Проверка UI в браузере** (так как это UI компонент):
   - **Автоматическая проверка (CursorAI)**:
     - Запустить `npm run dev`.
     - Открыть страницу с формой создания урока в браузере CursorAI.
     - **Проверка консоли браузера (ОБЯЗАТЕЛЬНО)**:
       - Использовать `mcp_console-ninja_runtime-errors` для проверки ошибок runtime.
       - Использовать `mcp_console-ninja_runtime-logs-and-errors` для полной проверки.
       - Проверить отсутствие ошибок сериализации (Decimal, Date).
       - Проверить отсутствие React ошибок (hydration, hooks, render).
       - Проверить отсутствие ошибок импорта модулей.
       - Проверить работу BlockNote редактора.
       - Если обнаружены ошибки - исправить их и повторить проверку.
       - Задокументировать результаты: "✅ Консоль браузера проверена - ошибок не обнаружено."
     - Проверить базовую функциональность (кнопки реагируют на клики, форма открывается, BlockNote работает).
     - Проверить Network tab на отсутствие failed запросов (если применимо).
     - Исправить любые технические ошибки.
   - **Визуальная проверка (требует разработчика)**:
     - Указать разработчику на необходимость проверки визуального соответствия дизайну.
     - Указать разработчику на необходимость проверки UX интерактивных элементов.
     - Указать разработчику на необходимость проверки адаптивности.

5. **Валидация сборки**:
   - Запустить `npm run build` и исправить любые ошибки сборки.
   - Проверить конфигурацию Prisma.
   - Перезапустить до тех пор, пока сборка не пройдет успешно.

6. **Симуляция Code Review**:
   - Проверить соответствие архитектуре, паттернам Server Actions, интеграции с Prisma, и доступности.
   - Проверить соответствие WCAG 2.1 AA для полей формы.
   - Пересмотреть код, если найдены проблемы, и повторить Шаги 3–5.

7. **Обновление документации**:
   - Обновить документацию задачи с деталями реализации и интеграцией с Prisma.
   - Обновить статус задачи в [`docs/tasks/mvp_tasks.md`](docs/tasks/mvp_tasks.md) (если файл существует):
     - Найти задачу "Создать `src/components/teacher/LessonForm.tsx`" и изменить статус с `- [ ]` на `- [x]`.
     - Найти задачу "Создать `src/actions/lessons.ts`" и изменить статус с `- [ ]` на `- [x]`.
     - Убедиться, что все выполненные подзадачи также отмечены как выполненные.

---

## Особенности MVP подхода

- **Фокус на работоспособность**: Код должен работать, даже если не идеален. Можно упростить для быстрого запуска.
- **Нет автоматизированных тестов**: В MVP не пишем тесты. Ручное тестирование достаточно.
- **Минимальный state management**: Использовать Zustand только когда действительно нужно. Server Components по умолчанию.
- **Простая структура**: Не переусложнять. Следовать простой структуре проекта.
- **Быстрый запуск**: Приоритет на скорость реализации, не на идеальный код.

---

## Структура проекта (напоминание)

```
src/
├── app/
│   ├── (auth)/                # Auth route group
│   │   └── login/
│   ├── (dashboard)/           # Dashboard route group
│   │   ├── grades/            # Управление группами
│   │   ├── lessons/           # Уроки
│   │   ├── homework-check/    # Проверка ДЗ
│   │   ├── pupil-personal-data/ # Личные карточки учеников
│   │   ├── grade-leaderboard/  # Рейтинг группы
│   │   └── golden-verses-library/ # Библиотека золотых стихов
│   ├── (admin)/               # Admin route group
│   │   ├── grades-list/        # Список всех групп
│   │   ├── teachers-management/ # Управление преподавателями
│   │   ├── pupils-management/  # Управление учениками
│   │   ├── families-management/ # Управление семьями
│   │   └── school-process-management/ # Управление учебным процессом
│   └── api/auth/              # Auth.js routes
├── actions/                    # Server Actions ⭐
│   ├── lessons.ts
│   ├── homework.ts
│   ├── pupils.ts
│   ├── teachers.ts
│   ├── grades.ts
│   ├── academic-years.ts
│   ├── golden-verses.ts
│   ├── achievements.ts
│   ├── families.ts
│   ├── schedule.ts
│   └── admin.ts
├── components/
│   ├── ui/                     # Shadcn UI (отдельная папка!) ⭐
│   ├── teacher/                # Компоненты для преподавателей
│   │   ├── LessonForm/
│   │   ├── HomeworkCheckTable/
│   │   ├── PupilCard/
│   │   ├── LeaderboardTable/
│   │   └── ScheduleCalendar/
│   ├── admin/                  # Компоненты для админ-панели
│   │   ├── AdminSidebar/
│   │   ├── AdminBreadcrumbs/
│   │   ├── TeachersTable/
│   │   ├── PupilsTable/
│   │   └── FamiliesTable/
│   └── shared/                 # Общие компоненты
│       ├── Header/
│       └── Footer/
├── lib/
│   ├── db/
│   │   └── prisma.ts           # Prisma client
│   ├── auth/
│   │   └── auth.ts             # Auth.js setup
│   └── utils.ts                # Утилиты
├── hooks/                       # Custom hooks (минимально)
└── types/                       # TypeScript types
```

---

**Версия документа**: 1.0 (MVP)  
**Последнее обновление**: 11 ноября 2025  
**Проект**: Sunday School App (MVP)  
**Архитектура**: Next.js 16 App Router, Prisma, Auth.js v5, Shadcn UI, BlockNote
